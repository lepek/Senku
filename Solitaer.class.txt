001    package de.hska.java.exercises.backtracking;
002    
003    /**
004     * Solves English peg solitare with 32 field and 31 pegs with the
005     * help of a recursive backtring algorithm.
006     * I have not checked every move of the solution: only the first few
007     * and last few moves. I hope all other are valid moves as well.
008     * 
009     * @author Christian Pape
010     *
011     */
012    public class Solitaer {
013    
014            /**
015             * the game board with values 1 (a peg), 2 (empty field), 0 (unused field)
016             */
017            private GameBoard board = new GameBoard();
018            
019            /**
020             * the solution given as a sequence of board situations
021             */
022            private GameBoard [] solution = new GameBoard[32];
023    
024            /**
025             * all four possible directions for a move (jump of a peg over another peg)
026             */
027            private int [] directions = board.getDirections();
028            
029            /**
030             * creates a new solitare instance with empty solution
031             * and initial start position of all pegs
032             */
033            public Solitaer() {
034                    for (int i = 0; i < solution.length; i++) {
035                            solution[i] = new GameBoard();
036                    }
037            }
038       /**
039        * Starts the backtracking algorithm and prints out the solution
040        * as the sequence of all resulting intermediate board situation
041            */
042            public static void main(String[] args) {
043                    Solitaer solitaer = new Solitaer();
044    
045                    long t1 = System.currentTimeMillis();
046                    if (solitaer.findSolution(1)) {
047                            System.out.println("Solution found in " + (System.currentTimeMillis() - t1) + " [ms]");
048    
049                            solitaer.printSolution();
050                    } else {
051                            System.out.println("No solution found!?");
052                    }
053            }
054    
055            /**
056             * Backtracking algorithm to solve the solitare puzzle
057             * 
058             * @param move current number of move, first move must be 1
059             */
060            public boolean findSolution(int move) {
061                    for (int x = 0; move <= 31 && x < board.getWidth(); x++) {
062                            for (int y = 0; y < board.getHeight(); y++) {
063                                    for (int direction : directions) {
064                                            if (board.jump(x, y, direction)) {
065                                                    board.copyBoard(board, solution[move]);
066                                                    if (! (move >= 31 && board.isOccupied(3, 3))) {
067                                                            if ( findSolution(move + 1)) {
068                                                                    return true;
069                                                            } else {
070                                                                    board.jumpBack(x, y, direction);
071                                                            }
072                                                    } else {
073                                                            return true;
074                                                    }
075                                            }
076                                    }
077                            }                       
078                    }
079                    
080                    return false;
081            }
082    
083            /**
084             * Gibt die LÃ¶sung als Folge von Spielbrettern am Bildschirm aus.
085             *
086             */
087            private void printSolution() {
088                    for (int zug = 0; zug < solution.length; zug++) {
089                            solution[zug].print();
090                    }
091            }
092    }


